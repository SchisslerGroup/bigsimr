---
title: "Overview of using bigsimr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Overview of using bigsimr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

options(use_jax = FALSE)

set.seed(2020-12-23)
```

```{r setup}
library(bigsimr)
```

# Basics

This package operates on the principle of Gaussian copulas, for which you will need a list of target marginal distributions and a correlation structure between the margins.

The main function is `bigsimr::rvec` which mirrors some of the conventions found in the base `stats` package like `stats::rnorm`. I.e. the common convention for generating a random vector is to first specify the number of samples followed by the parameters for the distribution.


```{r}
# To generate normally distributed samples, three things are needed:
#   1) The number of samples to generate
#   2) The location of the normal distribution (mean)
#   3) The scale of the normal distribution (standard deviation)
rnorm(n = 16, mean = 5, sd = 1.5)
```


The function `rvec` behaves similarly. It takes in as arguments the number of samples to generate, a correlation matrix, and a list of margins. The parameters of the margins can be arbitrary and the correlation matrix can take on values within a broad range constrained by the theoretical bounds. In the following sections we will go through the basic usage of `bigsimr` and the functionality within.

# Building a Multivariate Distribution

As stated earlier, to generate multivariate data, we need a list of marginals (and their parameters), and a correlation structure (matrix).

```{r}
margins <- list(
  Normal$new(mean = 3.14, sd = 0.1),
  Beta$new(shape1 = 1, shape2 = 4),
  NegativeBinomial$new(size = 10, prob = 0.75),
  Pareto$new(scale = 1.11, shape = 5.55)
)
```


The next step is to define a correlation structure for the multivariate distribution. This correlation matrix can either come from observed data, or we can set it ourselves, or we can generate a random correlation matrix via `bigsimr::cor_randPSD`. Since we have 4 marginals, we need a $4\times 4$ matrix.

```{r}
# rho <- bigsimr::cor_randPD(4)
rho <- bigsimr::cor_randPSD(4)
```

```{r, echo=FALSE}
round(rho, 3)
```


Finally we can generate a random vector with our specified marginals and correlation structure. The last argument, `type`, is looking to know what kind of correlation matrix it is receiving. Right now it can handle Pearson, Spearman, or Kendall.

If you have the CPU version of JAX installed, you may see an error similar to `warning.warn('No GPU/TPU found, falling back to CPU.')`. This message indicates that JAX is running on the CPU rather than a GPU/TPU.

```{r}
x <- bigsimr::rvec(10, rho = rho, margins = margins)
```

Taking a look at our random vector, we see that it has 10 rows and 4 columns, one column for each marginal distribution.

```{r}
x
```

We can simulate many more samples and then check the histogram of each margin, as well as the estimated correlation between the columns.

```{r}
x <- bigsimr::rvec(10000, rho = rho, margins = margins)
```

```{r, echo=FALSE}
hist(x[,1], breaks = 30, xlab = "", main = "Normal")
hist(x[,2], breaks = 30, xlab = "", main = "Beta")
hist(x[,3], breaks = 30, xlab = "", main = "Negative Binomial")
hist(x[,4], breaks = 30, xlab = "", main = "Pareto")
```

```{r}
round(bigsimr::cor_fast(x, method = "pearson"), 2)
```

```{r}
round(rho, 2)
```

We can see that even with 10,000 samples, the estimated correlation of the simulated data is not exactly the same as the target correlation. This can be explained by the fact that some correlations are simply not possible due to the discrete nature of certain distributions.

We can check the theoretical correlation bounds in bigsimr

```{r}
bigsimr::cor_bounds(margins, method = "pearson")
```
